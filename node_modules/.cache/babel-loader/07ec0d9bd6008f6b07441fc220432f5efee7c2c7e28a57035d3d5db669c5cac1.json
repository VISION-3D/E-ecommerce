{"ast":null,"code":"const threshold = 50;\nconst maxSpeed = 25;\nconst overflowStyles = new Set([\"auto\", \"scroll\"]);\n// Track initial scroll limits per scrollable element (Bug 1 fix)\nconst initialScrollLimits = new WeakMap();\nconst activeScrollEdge = new WeakMap();\n// Track which group element is currently dragging to clear state on end\nlet currentGroupElement = null;\nfunction resetAutoScrollState() {\n  if (currentGroupElement) {\n    const scrollableAncestor = findScrollableAncestor(currentGroupElement, \"y\");\n    if (scrollableAncestor) {\n      activeScrollEdge.delete(scrollableAncestor);\n      initialScrollLimits.delete(scrollableAncestor);\n    }\n    // Also try x axis\n    const scrollableAncestorX = findScrollableAncestor(currentGroupElement, \"x\");\n    if (scrollableAncestorX && scrollableAncestorX !== scrollableAncestor) {\n      activeScrollEdge.delete(scrollableAncestorX);\n      initialScrollLimits.delete(scrollableAncestorX);\n    }\n    currentGroupElement = null;\n  }\n}\nfunction isScrollableElement(element, axis) {\n  const style = getComputedStyle(element);\n  const overflow = axis === \"x\" ? style.overflowX : style.overflowY;\n  return overflowStyles.has(overflow);\n}\nfunction findScrollableAncestor(element, axis) {\n  let current = element?.parentElement;\n  while (current) {\n    if (isScrollableElement(current, axis)) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n  return null;\n}\nfunction getScrollAmount(pointerPosition, scrollElement, axis) {\n  const rect = scrollElement.getBoundingClientRect();\n  const start = axis === \"x\" ? rect.left : rect.top;\n  const end = axis === \"x\" ? rect.right : rect.bottom;\n  const distanceFromStart = pointerPosition - start;\n  const distanceFromEnd = end - pointerPosition;\n  if (distanceFromStart < threshold) {\n    const intensity = 1 - distanceFromStart / threshold;\n    return {\n      amount: -maxSpeed * intensity * intensity,\n      edge: \"start\"\n    };\n  } else if (distanceFromEnd < threshold) {\n    const intensity = 1 - distanceFromEnd / threshold;\n    return {\n      amount: maxSpeed * intensity * intensity,\n      edge: \"end\"\n    };\n  }\n  return {\n    amount: 0,\n    edge: null\n  };\n}\nfunction autoScrollIfNeeded(groupElement, pointerPosition, axis, velocity) {\n  if (!groupElement) return;\n  // Track the group element for cleanup\n  currentGroupElement = groupElement;\n  const scrollableAncestor = findScrollableAncestor(groupElement, axis);\n  if (!scrollableAncestor) return;\n  const {\n    amount: scrollAmount,\n    edge\n  } = getScrollAmount(pointerPosition, scrollableAncestor, axis);\n  // If not in any threshold zone, clear all state\n  if (edge === null) {\n    activeScrollEdge.delete(scrollableAncestor);\n    initialScrollLimits.delete(scrollableAncestor);\n    return;\n  }\n  const currentActiveEdge = activeScrollEdge.get(scrollableAncestor);\n  // If not currently scrolling this edge, check velocity to see if we should start\n  if (currentActiveEdge !== edge) {\n    // Only start scrolling if velocity is towards the edge\n    const shouldStart = edge === \"start\" && velocity < 0 || edge === \"end\" && velocity > 0;\n    if (!shouldStart) return;\n    // Activate this edge\n    activeScrollEdge.set(scrollableAncestor, edge);\n    // Record initial scroll limit (prevents infinite scroll)\n    const maxScroll = axis === \"x\" ? scrollableAncestor.scrollWidth - scrollableAncestor.clientWidth : scrollableAncestor.scrollHeight - scrollableAncestor.clientHeight;\n    initialScrollLimits.set(scrollableAncestor, maxScroll);\n  }\n  // Cap scrolling at initial limit (prevents infinite scroll)\n  if (scrollAmount > 0) {\n    const initialLimit = initialScrollLimits.get(scrollableAncestor);\n    const currentScroll = axis === \"x\" ? scrollableAncestor.scrollLeft : scrollableAncestor.scrollTop;\n    if (currentScroll >= initialLimit) return;\n  }\n  // Apply scroll\n  if (axis === \"x\") {\n    scrollableAncestor.scrollLeft += scrollAmount;\n  } else {\n    scrollableAncestor.scrollTop += scrollAmount;\n  }\n}\nexport { autoScrollIfNeeded, resetAutoScrollState };\n//# sourceMappingURL=auto-scroll.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}