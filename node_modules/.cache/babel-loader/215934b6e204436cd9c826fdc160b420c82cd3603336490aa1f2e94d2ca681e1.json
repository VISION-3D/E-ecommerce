{"ast":null,"code":"\"use client\";\n\nimport _objectSpread from \"D:/bureau/E-ecommerce/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { jsxs, jsx } from 'react/jsx-runtime';\nimport { warning, invariant } from 'motion-utils';\nimport { forwardRef, useContext } from 'react';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { useRender } from '../render/dom/use-render.mjs';\nimport { isSVGComponent } from '../render/dom/utils/is-svg-component.mjs';\nimport { useHTMLVisualState } from '../render/html/use-html-visual-state.mjs';\nimport { useSVGVisualState } from '../render/svg/use-svg-visual-state.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { getInitializedFeatureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createMotionComponent(Component) {\n  var _ref, _Component$displayNam;\n  let {\n    forwardMotionProps = false,\n    type\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let preloadedFeatures = arguments.length > 2 ? arguments[2] : undefined;\n  let createVisualElement = arguments.length > 3 ? arguments[3] : undefined;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  /**\n   * Determine whether to use SVG or HTML rendering based on:\n   * 1. Explicit `type` option (highest priority)\n   * 2. Auto-detection via `isSVGComponent`\n   */\n  const isSVG = type ? type === \"svg\" : isSVGComponent(Component);\n  const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState;\n  function MotionDOMComponent(props, externalRef) {\n    /**\n     * If we need to measure the element we load this functionality in a\n     * separate class component in order to gain access to getSnapshotBeforeUpdate.\n     */\n    let MeasureLayout;\n    const configAndProps = _objectSpread(_objectSpread(_objectSpread({}, useContext(MotionConfigContext)), props), {}, {\n      layoutId: useLayoutId(props)\n    });\n    const {\n      isStatic\n    } = configAndProps;\n    const context = useCreateMotionContext(props);\n    const visualState = useVisualState(props, isStatic);\n    if (!isStatic && isBrowser) {\n      useStrictMode(configAndProps, preloadedFeatures);\n      const layoutProjection = getProjectionFunctionality(configAndProps);\n      MeasureLayout = layoutProjection.MeasureLayout;\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode, isSVG);\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n    return jsxs(MotionContext.Provider, {\n      value: context,\n      children: [MeasureLayout && context.visualElement ? jsx(MeasureLayout, _objectSpread({\n        visualElement: context.visualElement\n      }, configAndProps)) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps, isSVG)]\n    });\n  }\n  MotionDOMComponent.displayName = \"motion.\".concat(typeof Component === \"string\" ? Component : \"create(\".concat((_ref = (_Component$displayNam = Component.displayName) !== null && _Component$displayNam !== void 0 ? _Component$displayNam : Component.name) !== null && _ref !== void 0 ? _ref : \"\", \")\"));\n  const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);\n  ForwardRefMotionComponent[motionComponentSymbol] = Component;\n  return ForwardRefMotionComponent;\n}\nfunction useLayoutId(_ref2) {\n  let {\n    layoutId\n  } = _ref2;\n  const layoutGroupId = useContext(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n  const isStrict = useContext(LazyContext).strict;\n  /**\n   * If we're in development mode, check to make sure we're not rendering a motion component\n   * as a child of LazyMotion, as this will break the file-size benefits of using it.\n   */\n  if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && isStrict) {\n    const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n    configAndProps.ignoreStrict ? warning(false, strictMessage, \"lazy-strict-mode\") : invariant(false, strictMessage, \"lazy-strict-mode\");\n  }\n}\nfunction getProjectionFunctionality(props) {\n  const featureDefinitions = getInitializedFeatureDefinitions();\n  const {\n    drag,\n    layout\n  } = featureDefinitions;\n  if (!drag && !layout) return {};\n  const combined = _objectSpread(_objectSpread({}, drag), layout);\n  return {\n    MeasureLayout: drag !== null && drag !== void 0 && drag.isEnabled(props) || layout !== null && layout !== void 0 && layout.isEnabled(props) ? combined.MeasureLayout : undefined,\n    ProjectionNode: combined.ProjectionNode\n  };\n}\nexport { createMotionComponent };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}