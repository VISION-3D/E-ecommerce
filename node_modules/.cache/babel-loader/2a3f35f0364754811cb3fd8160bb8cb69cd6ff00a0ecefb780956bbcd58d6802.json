{"ast":null,"code":"import { appearAnimationStore } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\nfunction handoffOptimizedAppearAnimation(elementId, valueName, frame) {\n  var _window$MotionHandoff, _window2;\n  const storeId = appearStoreId(elementId, valueName);\n  const optimisedAnimation = appearAnimationStore.get(storeId);\n  if (!optimisedAnimation) {\n    return null;\n  }\n  const {\n    animation,\n    startTime\n  } = optimisedAnimation;\n  function cancelAnimation() {\n    var _window$MotionCancelO, _window;\n    (_window$MotionCancelO = (_window = window).MotionCancelOptimisedAnimation) === null || _window$MotionCancelO === void 0 || _window$MotionCancelO.call(_window, elementId, valueName, frame);\n  }\n  /**\n   * We can cancel the animation once it's finished now that we've synced\n   * with Motion.\n   *\n   * Prefer onfinish over finished as onfinish is backwards compatible with\n   * older browsers.\n   */\n  animation.onfinish = cancelAnimation;\n  if (startTime === null || (_window$MotionHandoff = (_window2 = window).MotionHandoffIsComplete) !== null && _window$MotionHandoff !== void 0 && _window$MotionHandoff.call(_window2, elementId)) {\n    /**\n     * If the startTime is null, this animation is the Paint Ready detection animation\n     * and we can cancel it immediately without handoff.\n     *\n     * Or if we've already handed off the animation then we're now interrupting it.\n     * In which case we need to cancel it.\n     */\n    cancelAnimation();\n    return null;\n  } else {\n    return startTime;\n  }\n}\nexport { handoffOptimizedAppearAnimation };\n//# sourceMappingURL=handoff.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}