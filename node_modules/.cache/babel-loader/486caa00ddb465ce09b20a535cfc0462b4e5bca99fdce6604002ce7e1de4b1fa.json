{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { invariant } from 'motion-utils';\nimport { forwardRef, useRef, useEffect } from 'react';\nimport { ReorderContext } from '../../context/ReorderContext.mjs';\nimport { motion } from '../../render/components/motion/proxy.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { checkReorder } from './utils/check-reorder.mjs';\nfunction ReorderGroupComponent({\n  children,\n  as = \"ul\",\n  axis = \"y\",\n  onReorder,\n  values,\n  ...props\n}, externalRef) {\n  const Component = useConstant(() => motion[as]);\n  const order = [];\n  const isReordering = useRef(false);\n  const groupRef = useRef(null);\n  invariant(Boolean(values), \"Reorder.Group must be provided a values prop\", \"reorder-values\");\n  const context = {\n    axis,\n    groupRef,\n    registerItem: (value, layout) => {\n      // If the entry was already added, update it rather than adding it again\n      const idx = order.findIndex(entry => value === entry.value);\n      if (idx !== -1) {\n        order[idx].layout = layout[axis];\n      } else {\n        order.push({\n          value: value,\n          layout: layout[axis]\n        });\n      }\n      order.sort(compareMin);\n    },\n    updateOrder: (item, offset, velocity) => {\n      if (isReordering.current) return;\n      const newOrder = checkReorder(order, item, offset, velocity);\n      if (order !== newOrder) {\n        isReordering.current = true;\n        onReorder(newOrder.map(getValue).filter(value => values.indexOf(value) !== -1));\n      }\n    }\n  };\n  useEffect(() => {\n    isReordering.current = false;\n  });\n  // Combine refs if external ref is provided\n  const setRef = element => {\n    groupRef.current = element;\n    if (typeof externalRef === \"function\") {\n      externalRef(element);\n    } else if (externalRef) {\n      externalRef.current = element;\n    }\n  };\n  /**\n   * Disable browser scroll anchoring on the group container.\n   * When items reorder, scroll anchoring can cause the browser to adjust\n   * the scroll position, which interferes with drag position calculations.\n   */\n  const groupStyle = {\n    overflowAnchor: \"none\",\n    ...props.style\n  };\n  return jsx(Component, {\n    ...props,\n    style: groupStyle,\n    ref: setRef,\n    ignoreStrict: true,\n    children: jsx(ReorderContext.Provider, {\n      value: context,\n      children: children\n    })\n  });\n}\nconst ReorderGroup = /*@__PURE__*/forwardRef(ReorderGroupComponent);\nfunction getValue(item) {\n  return item.value;\n}\nfunction compareMin(a, b) {\n  return a.layout.min - b.layout.min;\n}\nexport { ReorderGroup, ReorderGroupComponent };\n//# sourceMappingURL=Group.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}