{"ast":null,"code":"import { HTMLProjectionNode } from '../projection/node/HTMLProjectionNode.mjs';\nimport { HTMLVisualElement } from '../render/html/HTMLVisualElement.mjs';\nimport { nodeGroup } from '../projection/node/group.mjs';\nimport { getLayoutId } from './get-layout-elements.mjs';\nimport { addScaleCorrector } from '../projection/styles/scale-correction.mjs';\nimport { correctBorderRadius } from '../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../projection/styles/scale-box-shadow.mjs';\nlet scaleCorrectorAdded = false;\n/**\n * Track active projection nodes per element to handle animation interruption.\n * When a new animation starts on an element that already has an active animation,\n * we need to stop the old animation so the new one can start from the current\n * visual position.\n */\nconst activeProjectionNodes = new WeakMap();\nfunction ensureScaleCorrectors() {\n  if (scaleCorrectorAdded) return;\n  scaleCorrectorAdded = true;\n  addScaleCorrector({\n    borderRadius: {\n      ...correctBorderRadius,\n      applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow\n  });\n}\n/**\n * Get DOM depth of an element\n */\nfunction getDepth(element) {\n  let depth = 0;\n  let current = element.parentElement;\n  while (current) {\n    depth++;\n    current = current.parentElement;\n  }\n  return depth;\n}\n/**\n * Find the closest projection parent for an element\n */\nfunction findProjectionParent(element, nodeCache) {\n  let parent = element.parentElement;\n  while (parent) {\n    const node = nodeCache.get(parent);\n    if (node) return node;\n    parent = parent.parentElement;\n  }\n  return undefined;\n}\n/**\n * Create or reuse a projection node for an element\n */\nfunction createProjectionNode(element, parent, options, transition) {\n  // Check for existing active node - reuse it to preserve animation state\n  const existingNode = activeProjectionNodes.get(element);\n  if (existingNode) {\n    const visualElement = existingNode.options.visualElement;\n    // Update transition options for the new animation\n    const nodeTransition = transition ? {\n      duration: transition.duration,\n      ease: transition.ease\n    } : {\n      duration: 0.3,\n      ease: \"easeOut\"\n    };\n    existingNode.setOptions({\n      ...existingNode.options,\n      animate: true,\n      transition: nodeTransition,\n      ...options\n    });\n    // Re-mount the node if it was previously unmounted\n    // This re-adds it to root.nodes so didUpdate() will process it\n    if (!existingNode.instance) {\n      existingNode.mount(element);\n    }\n    return {\n      node: existingNode,\n      visualElement\n    };\n  }\n  // No existing node - create a new one\n  const latestValues = {};\n  const visualElement = new HTMLVisualElement({\n    visualState: {\n      latestValues,\n      renderState: {\n        transformOrigin: {},\n        transform: {},\n        style: {},\n        vars: {}\n      }\n    },\n    presenceContext: null,\n    props: {}\n  });\n  const node = new HTMLProjectionNode(latestValues, parent);\n  // Convert AnimationOptions to transition format for the projection system\n  const nodeTransition = transition ? {\n    duration: transition.duration,\n    ease: transition.ease\n  } : {\n    duration: 0.3,\n    ease: \"easeOut\"\n  };\n  node.setOptions({\n    visualElement,\n    layout: true,\n    animate: true,\n    transition: nodeTransition,\n    ...options\n  });\n  node.mount(element);\n  visualElement.projection = node;\n  // Track this node as the active one for this element\n  activeProjectionNodes.set(element, node);\n  return {\n    node,\n    visualElement\n  };\n}\n/**\n * Build a projection tree from a list of elements\n */\nfunction buildProjectionTree(elements, existingContext, options) {\n  ensureScaleCorrectors();\n  const nodes = existingContext?.nodes ?? new Map();\n  const visualElements = existingContext?.visualElements ?? new Map();\n  const group = existingContext?.group ?? nodeGroup();\n  const defaultTransition = options?.defaultTransition;\n  const sharedTransitions = options?.sharedTransitions;\n  // Sort elements by DOM depth (parents before children)\n  const sorted = [...elements].sort((a, b) => getDepth(a) - getDepth(b));\n  let root = existingContext?.root;\n  for (const element of sorted) {\n    // Skip if already has a node\n    if (nodes.has(element)) continue;\n    const parent = findProjectionParent(element, nodes);\n    const layoutId = getLayoutId(element);\n    const layoutMode = element.getAttribute(\"data-layout\");\n    const nodeOptions = {\n      layoutId: layoutId ?? undefined,\n      animationType: parseLayoutMode(layoutMode)\n    };\n    // Use layoutId-specific transition if available, otherwise use default\n    const transition = layoutId && sharedTransitions?.get(layoutId) ? sharedTransitions.get(layoutId) : defaultTransition;\n    const {\n      node,\n      visualElement\n    } = createProjectionNode(element, parent, nodeOptions, transition);\n    nodes.set(element, node);\n    visualElements.set(element, visualElement);\n    group.add(node);\n    if (!root) {\n      root = node.root;\n    }\n  }\n  return {\n    nodes,\n    visualElements,\n    group,\n    root: root\n  };\n}\n/**\n * Parse the data-layout attribute value\n */\nfunction parseLayoutMode(value) {\n  if (value === \"position\") return \"position\";\n  if (value === \"size\") return \"size\";\n  if (value === \"preserve-aspect\") return \"preserve-aspect\";\n  return \"both\";\n}\n/**\n * Clean up projection nodes for specific elements.\n * If elementsToCleanup is provided, only those elements are cleaned up.\n * If not provided, all nodes are cleaned up.\n *\n * This allows persisting elements to keep their nodes between animations,\n * matching React's behavior where nodes persist for elements that remain in the DOM.\n */\nfunction cleanupProjectionTree(context, elementsToCleanup) {\n  const elementsToProcess = elementsToCleanup ? [...context.nodes.entries()].filter(([el]) => elementsToCleanup.has(el)) : [...context.nodes.entries()];\n  for (const [element, node] of elementsToProcess) {\n    context.group.remove(node);\n    node.unmount();\n    // Only clear from activeProjectionNodes if this is still the active node.\n    // A newer animation might have already taken over.\n    if (activeProjectionNodes.get(element) === node) {\n      activeProjectionNodes.delete(element);\n    }\n    context.nodes.delete(element);\n    context.visualElements.delete(element);\n  }\n}\nexport { buildProjectionTree, cleanupProjectionTree };\n//# sourceMappingURL=projection-tree.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}