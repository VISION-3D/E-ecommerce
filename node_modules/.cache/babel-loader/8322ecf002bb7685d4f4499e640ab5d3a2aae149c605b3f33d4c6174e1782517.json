{"ast":null,"code":"import _objectSpread from \"D:/bureau/E-ecommerce/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"D:/bureau/E-ecommerce/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"autoplay\", \"delay\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\", \"keyframes\", \"name\", \"motionValue\", \"element\"];\nimport { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { makeAnimationInstant } from './utils/make-animation-instant.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n  constructor(_ref) {\n    var _this$keyframeResolve2;\n    let {\n        autoplay = true,\n        delay = 0,\n        type = \"keyframes\",\n        repeat = 0,\n        repeatDelay = 0,\n        repeatType = \"loop\",\n        keyframes,\n        name,\n        motionValue,\n        element\n      } = _ref,\n      options = _objectWithoutProperties(_ref, _excluded);\n    super();\n    /**\n     * Bound to support return animation.stop pattern\n     */\n    this.stop = () => {\n      var _this$keyframeResolve;\n      if (this._animation) {\n        var _this$stopTimeline;\n        this._animation.stop();\n        (_this$stopTimeline = this.stopTimeline) === null || _this$stopTimeline === void 0 || _this$stopTimeline.call(this);\n      }\n      (_this$keyframeResolve = this.keyframeResolver) === null || _this$keyframeResolve === void 0 || _this$keyframeResolve.cancel();\n    };\n    this.createdAt = time.now();\n    const optionsWithDefaults = _objectSpread({\n      autoplay,\n      delay,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType,\n      name,\n      motionValue,\n      element\n    }, options);\n    const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n    this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n    (_this$keyframeResolve2 = this.keyframeResolver) === null || _this$keyframeResolve2 === void 0 || _this$keyframeResolve2.scheduleResolve();\n  }\n  onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n    this.keyframeResolver = undefined;\n    const {\n      name,\n      type,\n      velocity,\n      delay,\n      isHandoff,\n      onUpdate\n    } = options;\n    this.resolvedAt = time.now();\n    /**\n     * If we can't animate this value with the resolved keyframes\n     * then we should complete it immediately.\n     */\n    if (!canAnimate(keyframes, name, type, velocity)) {\n      if (MotionGlobalConfig.instantAnimations || !delay) {\n        onUpdate === null || onUpdate === void 0 || onUpdate(getFinalKeyframe(keyframes, options, finalKeyframe));\n      }\n      keyframes[0] = keyframes[keyframes.length - 1];\n      makeAnimationInstant(options);\n      options.repeat = 0;\n    }\n    /**\n     * Resolve startTime for the animation.\n     *\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first committed frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : undefined;\n    const resolvedOptions = _objectSpread(_objectSpread({\n      startTime,\n      finalKeyframe\n    }, options), {}, {\n      keyframes\n    });\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended(_objectSpread(_objectSpread({}, resolvedOptions), {}, {\n      element: resolvedOptions.motionValue.owner.current\n    })) : new JSAnimation(resolvedOptions);\n    animation.finished.then(() => this.notifyFinished()).catch(noop);\n    if (this.pendingTimeline) {\n      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n      this.pendingTimeline = undefined;\n    }\n    this._animation = animation;\n  }\n  get finished() {\n    if (!this._animation) {\n      return this._finished;\n    } else {\n      return this.animation.finished;\n    }\n  }\n  then(onResolve, _onReject) {\n    return this.finished.finally(onResolve).then(() => {});\n  }\n  get animation() {\n    if (!this._animation) {\n      var _this$keyframeResolve3;\n      (_this$keyframeResolve3 = this.keyframeResolver) === null || _this$keyframeResolve3 === void 0 || _this$keyframeResolve3.resume();\n      flushKeyframeResolvers();\n    }\n    return this._animation;\n  }\n  get duration() {\n    return this.animation.duration;\n  }\n  get iterationDuration() {\n    return this.animation.iterationDuration;\n  }\n  get time() {\n    return this.animation.time;\n  }\n  set time(newTime) {\n    this.animation.time = newTime;\n  }\n  get speed() {\n    return this.animation.speed;\n  }\n  get state() {\n    return this.animation.state;\n  }\n  set speed(newSpeed) {\n    this.animation.speed = newSpeed;\n  }\n  get startTime() {\n    return this.animation.startTime;\n  }\n  attachTimeline(timeline) {\n    if (this._animation) {\n      this.stopTimeline = this.animation.attachTimeline(timeline);\n    } else {\n      this.pendingTimeline = timeline;\n    }\n    return () => this.stop();\n  }\n  play() {\n    this.animation.play();\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.complete();\n  }\n  cancel() {\n    var _this$keyframeResolve4;\n    if (this._animation) {\n      this.animation.cancel();\n    }\n    (_this$keyframeResolve4 = this.keyframeResolver) === null || _this$keyframeResolve4 === void 0 || _this$keyframeResolve4.cancel();\n  }\n}\nexport { AsyncMotionValueAnimation };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}