{"ast":null,"code":"import { Feature } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { VisualElementDragControls } from './VisualElementDragControls.mjs';\nclass DragGesture extends Feature {\n  constructor(node) {\n    super(node);\n    this.removeGroupControls = noop;\n    this.removeListeners = noop;\n    this.controls = new VisualElementDragControls(node);\n  }\n  mount() {\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    const {\n      dragControls\n    } = this.node.getProps();\n    if (dragControls) {\n      this.removeGroupControls = dragControls.subscribe(this.controls);\n    }\n    this.removeListeners = this.controls.addListeners() || noop;\n  }\n  update() {\n    const {\n      dragControls\n    } = this.node.getProps();\n    const {\n      dragControls: prevDragControls\n    } = this.node.prevProps || {};\n    if (dragControls !== prevDragControls) {\n      this.removeGroupControls();\n      if (dragControls) {\n        this.removeGroupControls = dragControls.subscribe(this.controls);\n      }\n    }\n  }\n  unmount() {\n    this.removeGroupControls();\n    this.removeListeners();\n    /**\n     * In React 19, during list reorder reconciliation, components may\n     * briefly unmount and remount while the drag is still active. If we're\n     * actively dragging, we should NOT end the pan session - it will\n     * continue tracking pointer events via its window-level listeners.\n     *\n     * The pan session will be properly cleaned up when:\n     * 1. The drag ends naturally (pointerup/pointercancel)\n     * 2. The component is truly removed from the DOM\n     */\n    if (!this.controls.isDragging) {\n      this.controls.endPanSession();\n    }\n  }\n}\nexport { DragGesture };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}