{"ast":null,"code":"\"use client\";\n\nimport { useRef, useInsertionEffect, useCallback } from 'react';\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n  /**\n   * Store externalRef in a ref to avoid including it in the useCallback\n   * dependency array. Including externalRef in dependencies causes issues\n   * with libraries like Radix UI that create new callback refs on each render\n   * when using asChild - this would cause the callback to be recreated,\n   * triggering element remounts and breaking AnimatePresence exit animations.\n   */\n  const externalRefContainer = useRef(externalRef);\n  useInsertionEffect(() => {\n    externalRefContainer.current = externalRef;\n  });\n  // Store cleanup function returned by callback refs (React 19 feature)\n  const refCleanup = useRef(null);\n  return useCallback(instance => {\n    if (instance) {\n      visualState.onMount?.(instance);\n    }\n    if (visualElement) {\n      instance ? visualElement.mount(instance) : visualElement.unmount();\n    }\n    const ref = externalRefContainer.current;\n    if (typeof ref === \"function\") {\n      if (instance) {\n        const cleanup = ref(instance);\n        if (typeof cleanup === \"function\") {\n          refCleanup.current = cleanup;\n        }\n      } else if (refCleanup.current) {\n        refCleanup.current();\n        refCleanup.current = null;\n      } else {\n        ref(instance);\n      }\n    } else if (ref) {\n      ref.current = instance;\n    }\n  }, [visualElement]);\n}\nexport { useMotionRef };\n//# sourceMappingURL=use-motion-ref.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}