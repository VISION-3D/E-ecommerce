{"ast":null,"code":"import _objectSpread from \"D:/bureau/E-ecommerce/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { calcChildStagger } from '../utils/calc-child-stagger.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\nfunction animateVariant(visualElement, variant) {\n  var _visualElement$presen;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const resolved = resolveVariant(visualElement, variant, options.type === \"exit\" ? (_visualElement$presen = visualElement.presenceContext) === null || _visualElement$presen === void 0 ? void 0 : _visualElement$presen.custom : undefined);\n  let {\n    transition = visualElement.getDefaultTransition() || {}\n  } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? function () {\n    let forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const {\n      delayChildren = 0,\n      staggerChildren,\n      staggerDirection\n    } = transition;\n    return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n  const {\n    when\n  } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];\n    return first().then(() => last());\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateChildren(visualElement, variant) {\n  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let delayChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let staggerChildren = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let staggerDirection = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;\n  let options = arguments.length > 6 ? arguments[6] : undefined;\n  const animations = [];\n  for (const child of visualElement.variantChildren) {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, _objectSpread(_objectSpread({}, options), {}, {\n      delay: delay + (typeof delayChildren === \"function\" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)\n    })).then(() => child.notify(\"AnimationComplete\", variant)));\n  }\n  return Promise.all(animations);\n}\nexport { animateVariant };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}