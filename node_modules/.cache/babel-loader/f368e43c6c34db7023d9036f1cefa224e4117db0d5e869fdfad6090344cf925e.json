{"ast":null,"code":"import { noop } from 'motion-utils';\nimport { GroupAnimation } from '../animation/GroupAnimation.mjs';\nimport { getLayoutElements } from './get-layout-elements.mjs';\nimport { buildProjectionTree, cleanupProjectionTree } from './projection-tree.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\nimport { frame } from '../frameloop/frame.mjs';\nclass LayoutAnimationBuilder {\n  constructor(scope, updateDom, defaultOptions) {\n    this.sharedTransitions = new Map();\n    this.notifyReady = noop;\n    this.executed = false;\n    this.scope = scope;\n    this.updateDom = updateDom;\n    this.defaultOptions = defaultOptions;\n    this.readyPromise = new Promise(resolve => {\n      this.notifyReady = resolve;\n    });\n    // Queue execution on microtask to allow builder methods to be called\n    queueMicrotask(() => this.execute());\n  }\n  shared(id, options) {\n    this.sharedTransitions.set(id, options);\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    return this.readyPromise.then(onfulfilled, onrejected);\n  }\n  async execute() {\n    if (this.executed) return;\n    this.executed = true;\n    let context;\n    // Phase 1: Pre-mutation - Build projection tree and take snapshots\n    const beforeElements = getLayoutElements(this.scope);\n    if (beforeElements.length > 0) {\n      context = buildProjectionTree(beforeElements, undefined, this.getBuildOptions());\n      context.root.startUpdate();\n      for (const node of context.nodes.values()) {\n        node.isLayoutDirty = false;\n        node.willUpdate();\n      }\n    }\n    // Phase 2: Execute DOM update\n    this.updateDom();\n    // Phase 3: Post-mutation - Compare before/after elements\n    const afterElements = getLayoutElements(this.scope);\n    const beforeSet = new Set(beforeElements);\n    const afterSet = new Set(afterElements);\n    const entering = afterElements.filter(el => !beforeSet.has(el));\n    const exiting = beforeElements.filter(el => !afterSet.has(el));\n    // Build projection nodes for entering elements\n    if (entering.length > 0) {\n      context = buildProjectionTree(entering, context, this.getBuildOptions());\n    }\n    // No layout elements - return empty animation\n    if (!context) {\n      this.notifyReady(new GroupAnimation([]));\n      return;\n    }\n    // Handle shared elements\n    for (const element of exiting) {\n      const node = context.nodes.get(element);\n      node?.getStack()?.remove(node);\n    }\n    for (const element of entering) {\n      context.nodes.get(element)?.promote();\n    }\n    // Phase 4: Animate\n    context.root.didUpdate();\n    await new Promise(resolve => frame.postRender(() => resolve()));\n    const animations = [];\n    for (const node of context.nodes.values()) {\n      if (node.currentAnimation) {\n        animations.push(node.currentAnimation);\n      }\n    }\n    const groupAnimation = new GroupAnimation(animations);\n    groupAnimation.finished.then(() => {\n      // Only clean up nodes for elements no longer in the document.\n      // Elements still in DOM keep their nodes so subsequent animations\n      // can use the stored position snapshots (A→B→A pattern).\n      const elementsToCleanup = new Set();\n      for (const element of context.nodes.keys()) {\n        if (!document.contains(element)) {\n          elementsToCleanup.add(element);\n        }\n      }\n      cleanupProjectionTree(context, elementsToCleanup);\n    });\n    this.notifyReady(groupAnimation);\n  }\n  getBuildOptions() {\n    return {\n      defaultTransition: this.defaultOptions || {\n        duration: 0.3,\n        ease: \"easeOut\"\n      },\n      sharedTransitions: this.sharedTransitions.size > 0 ? this.sharedTransitions : undefined\n    };\n  }\n}\n/**\n * Parse arguments for animateLayout overloads\n */\nfunction parseAnimateLayoutArgs(scopeOrUpdateDom, updateDomOrOptions, options) {\n  // animateLayout(updateDom)\n  if (typeof scopeOrUpdateDom === \"function\") {\n    return {\n      scope: document,\n      updateDom: scopeOrUpdateDom,\n      defaultOptions: updateDomOrOptions\n    };\n  }\n  // animateLayout(scope, updateDom, options?)\n  const elements = resolveElements(scopeOrUpdateDom);\n  const scope = elements[0] || document;\n  return {\n    scope: scope instanceof Document ? scope : scope,\n    updateDom: updateDomOrOptions,\n    defaultOptions: options\n  };\n}\nexport { LayoutAnimationBuilder, parseAnimateLayoutArgs };\n//# sourceMappingURL=LayoutAnimationBuilder.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}